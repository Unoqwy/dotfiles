#!/bin/python3

import sys
import os
import yaml

from pathlib import Path


PKG_MANAGERS = {
    "pacman": (True, [
        ("community.general.pacman", ("package", "{0}")),
        ("when", "ansible_pkg_mgr == 'pacman'"),
        ("become", "yes"),
    ], "pacman"),
    "aur": (True, [
        ("kewlfft.aur.aur", [("use", "paru"), ("name", "{0}")]),
        ("when", "ansible_pkg_mgr == 'pacman'")
    ], "paru"),
}


## Packages

def generate_install_file_contents(pkgs_desc):
    contents = []
    if "_" in pkgs_desc:
        # Alternative way allowing to comment groups
        groups = pkgs_desc["_"]
        for group in groups:
            for pkg_manager in group.keys():
                if not pkg_manager in PKG_MANAGERS.keys():
                    continue
                generate_pkgs_contents(pkg_manager, group[pkg_manager], contents)
    else:
        for pkg_manager in PKG_MANAGERS.keys():
            if not pkg_manager in pkgs_desc:
                continue
            generate_pkgs_contents(pkg_manager, pkgs_desc[pkg_manager], contents)
    return contents


def generate_pkgs_contents(pkg_manager, pkgs, contents):
    if not isinstance(pkgs, list):
        pkgs = [pkgs]
    support_list, items, rename = PKG_MANAGERS[pkg_manager]
    if support_list:
        str_pkgs = [pkg_to_str(pkg) for pkg in pkgs]
        entry = { "name": f"Install {','.join(str_pkgs)} with {rename}" }
        for append in items:
            write_to_entry(entry, pkgs, append)
        contents.append(entry)
    else:
        for pkg in pkgs:
            entry = { "name": f"Install {pkg} with {rename}" }
            for append in items:
                write_to_entry(entry, pkg, append)
            contents.append(entry)


def pkg_to_str(pkg) -> str:
    if isinstance(pkg, dict):
        return pkg['name']
    return pkg


def write_to_entry(entry, pkg, append):
    key, val = append
    if isinstance(val, tuple):
        sub = {}
        write_to_entry(sub, pkg, val)
        entry[key] = sub
    elif isinstance(val, list):
        sub = {}
        for subval in val:
            write_to_entry(sub, pkg, subval)
        entry[key] = sub
    else:
        if isinstance(pkg, list) and val == "{0}":
            entry[key] = pkg
        else:
            entry[key] = val.format(pkg)


## Role entries




## Generate

def write_yml_file(path, yml_dict):
    with open(path, "w") as file:
        dump = "\n".join([
            "# This file was auto-generated.",
            "# See `ansible/scripts/generate_tasks",
            "",
            yaml.dump(yml_dict)
        ])
        file.write(dump)


def visit_role_dir(src_path, dest_path, group: str, role: str):
    tasks_dir = os.path.join(src_path, "tasks")
    if os.path.isdir(tasks_dir):
        import_tasks = [os.path.abspath(path) for path in Path(tasks_dir).rglob("*.yml")]
    else:
        import_tasks = []

    pkgs_path = os.path.join(src_path, "packages.yml")
    if os.path.isfile(pkgs_path):
        install_file_path = os.path.join(dest_path, "install_packages.yml")
        with open(pkgs_path, "r") as fs:
            try:
                pkgs_desc = yaml.safe_load(fs)
                install_contents = generate_install_file_contents(pkgs_desc)
                if install_contents:
                    write_yml_file(install_file_path, install_contents)
                    import_tasks.insert(0, "install_packages.yml")
            except yaml.YAMLError:
                print(f"YAML file '{pkgs_path}' cannot be parsed.", file=sys.stderr)

    main = [{"import_tasks": task} for task in import_tasks]
    write_yml_file(os.path.join(dest_path, "main.yml"), main)

    print(f"Written tasks for {group}/{role}")


if __name__ == "__main__":
    generated_dir = os.path.join(".generated", "roles")
    for group in os.listdir("roles"):
        roles_dir = os.path.join("roles", group)
        if not os.path.isdir(roles_dir):
            continue

        for role in os.listdir(roles_dir):
            dir_path = os.path.join(roles_dir, role)
            if not os.path.isdir(dir_path):
                continue
            dest_path = os.path.join(generated_dir, f"{role}", "tasks")
            if not os.path.isdir(dest_path):
                os.makedirs(dest_path)
            visit_role_dir(dir_path, dest_path, group, role)
